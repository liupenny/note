# OS

[TOC]

# 内存管理

## 进程：物理内存、虚拟内存、共享内存

1. OS只有4G的物理内存，但有多个进程同时运行，且每个进程都需要很多内存，所以为满足多个程序能并行，每个进程都认为自己得到了4G虚拟内存。实际上每个进程用多少内存再对应多少

2. 对进程而言：他得到的4G虚拟内存是一个连续的地址空间，而实际上他是被分割成多个物理内存碎片，还有一部分存储在磁盘上，在需要时进行数据交换。

3. 进程通过页表记录：哪些地址空间的数据在物理内存上，在哪里。要访问虚拟地址的时候，先去看页表，如果对应页数据不在物理内存上，就会发生缺页异常，os会阻塞该进程，将硬盘里对应的页换入内存，如果内存满了，就找一个页覆盖（根据os中的）

4. 虚拟内存：当每个进程创建的时候，内核为其分配虚拟内存，但并不将磁盘里对应的数据和代码拷入，只是建立存储器映射；当发生缺页异常时才拷贝。malloc也是一样原理。

   mmap：建立虚拟空间和磁盘空间的映射关系

5. 共享内存
   <1>共享内存是一种最为高效的进程间通信方式，进程可以直接读写内存，而不需要任何数据的拷贝。

   <2>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。

   <3>由于多个进程共享一段内存，因此也需要依靠某种同步机制。

## 需求

1. 重定位

   现在操作系统中, 一个进程运行过程中可能会因为进程切换而在内存和磁盘中来回切换。如果没有重定位, 进程在重新回到内存来运行的时候, 就必须要加载到上一次在内存中运行的时候的同一段内存当中。这样对操作系统的管理来说是一个非常大的成本。

2. 保护

   主要是为了避免进程A通过各种手段读取或者修改了进程B的数据。

3. 共享

   在同一台机器上运行的多个进程, 势必会有不同进程要访问同一个内存块的需求。这里就需要共享内存的机制了。

   最典型的例子是, 当同一个二进制文件起了多个进程的时候, 访问二进制文件程序的时候, 最好是访问同一份, 而不是访问多份。

## 分区

内存分区要解决的问题就是一个进程所需要的内存到底是怎么在物理内存中给他分配的。历史上存在的一些方案整理如下：

| 方案         | 说明                                                         | 优势                                 | 劣势                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------ | ------------------------------------------------------------ |
| 固定分区     | 在系统初始化的时候, 将可用内存划分成数个大小相等或者不等的内存区域。每次进程运行的时候可以加载到某个大于自己所需内存的内存区域中。 | 实现简单, 只需要很少的操作系统开销   | 有大量的内存碎片, 内存利用不充分                             |
| 动态分区     | 同固定分区, 只是每次都在内存中动态分配一个跟进程所需内存一样大小的内存块用来装内存 | 没有内部碎片, 内存利用更充分         | 随着进程的启动和终止, 还是不可避免的会有碎片出现, 为了提高内存利用率, 又得增加压缩内存的处理进程, 在压缩过程中消耗巨大 |
| 简单分页     | 将主存划分为大小相同的小区块, 进程所需内存也划分为同样大小的区块。进程所需内存被装入到不一定连续的区块中。 | 没有外部碎片                         | 无                                                           |
| 简单分段     | 类似动态分区, 只是将进程分成数个段, 每个段单独申请一块内存   | 相比动态分区, 提高了内存利用效率     | 还是会有外部碎片以及内存整理的工作                           |
| 虚拟内存分页 | 跟简单分页一样, 只是不需要一次性将所有进程所需内存都加载到内存中, 按需索取 | 内存使用效率更高, 巨大的虚拟地址空间 | 复杂的内存管理                                               |
| 虚拟内存分段 | 跟简单分段类似, 但是不需要一次性加载所有分段, 按需加载       | 同虚拟内存分页                       | 复杂的内存管理                                               |

[操作系统之内存管理科普](http://www.cnblogs.com/xuanku/p/os_memory.html)



# 指令操作

## 内存：

free：

![img](assets/952033-20171206202441863-155675597.png)

**Mem** 行(第二行)是内存的使用情况。
**Swap** 行(第三行)是交换空间的使用情况。
**total** 列显示系统总的可用物理内存和交换空间大小。
**used** 列显示已经被使用的物理内存和交换空间。
**free** 列显示还有多少物理内存和交换空间可用使用。
**shared** 列显示被共享使用的物理内存大小。
**buff/cache** 列显示被 buffer 和 cache 使用的物理内存大小。
**available** 列显示还可以被应用程序使用的物理内存大小。

- buff与cache

扇区：设备的最小寻址单元；

块：操作系统中文件系统的最小寻址单元。一个页包含多个块，一个块包含多个扇区

- free与available

free：真正尚未被使用的物理内存数量。

available：从应用程序的角度看到的可用内存数量，=free + buffer +cache，因为当没有足够的free内存时，可从cache中回收

## cpu：

1. top：输出有系统信息栏、进程列表栏

   **系统信息栏：**

   第一行（top）：
   　　　　“00:11:04”为系统当前时刻；
   　　　　“3:35”为系统启动后到现在的运作时间；
   　　　　“2 users”为当前登录到系统的用户，更确切的说是登录到用户的终端数 --同一个用户同一时间对系统多个终端的连接将被视为多个用户连接到系统，这里的用户数也将表现为终端的数目；
   　　　　“load average”为当前系统负载的平均值，后面的三个值分别为1分钟前、5分钟前、15分钟前进程的平均数，当这个数值超过 CPU 数目时，CPU 将比较吃力的负载当前系统所包含的进程；
   第二行（Tasks）：
   　　　　“59 total”为当前系统进程总数；
   　　　　“1 running”为当前运行中的进程数；
   　　　　“58 sleeping”为当前处于等待状态中的进程数；
   　　　　“0 stoped”为被停止的系统进程数；
   　　　　“0 zombie”为被复原的进程数；
   第三行（Cpus）：
   　　　　分别表示了 CPU 当前的使用率；
   第四行（Mem）：
   　　　　分别表示了内存总量、当前使用量、空闲内存量、以及缓冲使用中的内存量；
   第五行（Swap）：
   　　　　表示类别同第四行（Mem），但此处反映着交换分区（Swap）的使用情况。

   通常，交换分区（Swap）被频繁使用的情况，将被视作物理内存不足而造成的。

   **进程列表栏：**

​	PID：进程的ID
　　USER：进程所有者
　　PR：进程的优先级别，越小越优先被执行
　　NInice：值
　　VIRT：进程占用的虚拟内存
　　RES：进程占用的物理内存
　　SHR：进程使用的共享内存
　　S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数
　　%CPU：进程占用CPU的使用率
　　%MEM：进程使用的物理内存和总内存的百分比
　　TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。

　　COMMAND：进程启动命令名称

## 进程：

ps：列出系统中当前运行的进程快照，使用top命令可以动态看到全部进程

ps -aux：显示所有包含其他使用者的行程 

# 父子进程的关系：

1. 共享代码空间，数据空间独立
2. 子进程从fork的地方开始运行