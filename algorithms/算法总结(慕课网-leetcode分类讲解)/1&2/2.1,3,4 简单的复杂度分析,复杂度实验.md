## 复杂度
### 概念
- 理论上，O（f(n)）表示运行算法所需要的指令数和f(n)成正比，表示算法执行的上界
- 在业界，用O表示算法执行的最低上界
- 如果算法分成两部分，那整体的复杂度不一定是两部分相加，有可能这两个部分针对的规模n是不同的。
- 对于logaN 和 logbN。logaN = logab * logbN, 可以看出二者相差一个常数系数，所以一般对数级的时间复杂度不考虑底数。

#### 比如
1. 对图进行遍历，其复杂度是O（V+E），V是点的规模，E是边的规模
2. 有一个字符串数组，将数组中的每一个字符串按照字母序排序；然后将整个字符串数组按照字典序排序。
- 假设最长的字符串长度是s, 数组中有n个字符串。
- 对每一个字符串排序是 O（slogs）
- 对数组中所有字符串排序 O（n*s*logs）
- 再对数组按字典序排序 O（s*n*logn）, 因为字符串的比较次数是字符串的长度，整数的比较次数是1
- 所以整体就是 O（n*s*logs + s*n*logn）

### 复杂度的说明是和用例相关的
一般取平均情况

### 复杂度试验
Q：自己写出来是nlogn的，但是OJ上超时，说是n^2的。  
A：通过实验，观察趋势，每次将数据规模提高两倍，看时间的变化，来确定算法的时间复杂度
- logn算法: log2n/logn = (log2 + logn)/logn = 1 + log2/logn ，log2/logn是一个很小的数，所以当数据规模变为原来的2倍的时候，复杂度会很小。所以这是一个很好的算法。
- nlogn算法：n变为原来2倍的时候，时间也为原来2倍多一点，所以类似一个O（n）的算法







