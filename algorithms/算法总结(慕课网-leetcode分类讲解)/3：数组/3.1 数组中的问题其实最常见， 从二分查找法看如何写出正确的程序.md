
### 排序，查找，数据结构（堆，队列）。都是在数组中进行实现的

### 如何写出正确的程序
- 声明变量的时候，要明确变量的意义；
- 循环不变量：在逻辑的编写上，要一直维护这个意义。
- 小数据量调试：0，null......
- 大数据量测试

#### 举例：二分查找法。重点问题在于边界处理
```
int binarySearch(T arr[], int n, T target)
{
    // 左右边界的设置，要严格地确定下来l,r的定义和要做什么
    // 在[l...r]的范围里寻找target，注意是闭区间
    int l = 0, r = n-1;
    
    // 这个边界考虑，当l==r时，[l...r] = [l]是一个有效区间，所以仍然应该进行判断
    while(l <= r)
    {
        int mid = (l + r) /2;
        if(arr[mid] == target)
            return mid;
        if(target > arr[mid])
        // 要更新左边界，就要回到左边界的定义上，即：target在闭区间[l...r]。此时已知mid！=target，所以l取mid + 1
            l = mid + 1;
        else
            r = mid - 1;
    }
    
    return -1;
}
```
- ==**循环不变量**==  
1. 循环不变量就是指循环中保证的这个声明是一直不变的，本题中就是：target一定在[l...r]中。多看看基础算法的循环不变量，包括：用数组实现队列
2. 整个流程的重点在于明确l,r的意义，在下面的循环体中，一直维护这个意义。
3. 如果一开始`l = 0, r = n`，那此时循环不变量的意义是target在[l...r)前闭后开区间内，  
代码改成:  
`while(l < r)`e.g. [4,4) : 这个区间是没东西的

```
if(target > arr[mid])
// 要更新左边界，已知mid！=target，所以l取mid + 1.右边不发生变化。即：target在前闭后开区间[mid+1...r）。此时
    l = mid + 1;
else
// r表示开区间的边界，已知mid！=target, 所以target在闭区间[l...mid-1],也就是前闭后开区间[l...mid)上
    r = mid;
```
4. ` int mid = (l + r) /2;` 可能会整形溢出，应该用`int mid = l + ( r - l) /2;` 所以之后也要注意一下，数据给出范围时要看看会不会溢出。
5. 小数据量调试：包含错误输入、空输入。
6. 大数据量测试：测试性能、稳定性

