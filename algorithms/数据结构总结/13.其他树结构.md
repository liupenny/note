# 其他树结构

## 1.判断二叉树是否为平衡二叉树

### 题目

平衡二叉树的性质为：要么是一棵空树，要么任何一个节点的左右子树高度差的绝对值不超过1。给定一棵二叉树的头节点head，判断这棵二叉树是否为平衡二叉树。

### 思路：

1：对于单个节点node，需要的信息 ：左子树高度h，左子树是否平衡 和 右子树高度h，右子树是否平衡。然后返回给上级，我的高度 + 我是否平衡。

2：res[0]放的是结果，当有一个判断得到不是平衡树就返回。

## 2.判断一棵二叉树是否为搜索二叉树和完全二叉树

### 题目

给定一个二叉树的头节点head，已知其中没有重复值的节点，实现两个函数分别判断这棵二叉树是否是搜索二叉树和完全二叉树。

### 搜索二叉树：

左子树的节点都比当前节点的值小，右子树的节点都大于当前节点的值。搜索的时候类似于二分。

![img](C:/Users/PennyLiu/AppData/Local/YNote/data/liurqbupt@163.com/42ba556dfcbc46c5a91155090226aad6/clipboard.png)

因为搜索二叉树的中序遍历是递增的，所以用Morris中序遍历看是否递增即可。

插入：按顺序搜索，插入即可

删除：

![img](C:/Users/PennyLiu/AppData/Local/YNote/data/liurqbupt@163.com/9758d5870c0e485da4379048a75e2bfa/clipboard.png)

当前节点有两个孩子怎么删除：

选择 前驱节点（左子树的最右节点来代替也可以），后继节点6（右子树最左的节点）来接替自己都可以。

找到后继以后，先把后继移除，再用后继去替代当前节点。

6出来：右孩子占据自己，给7

5出来，6给他

### 完全二叉树：

按层次宽度优先遍历--队列。

标准：1 若当前节点有右孩子无左孩子，不是

   2 若节点左右孩子不全，则后面的节点必须没有左右孩子节点

   3 left表示阶段切换

问题：如果搜索树不是平衡的，那搜索代价就会很大。所以有很多方式去定义平衡性，进行相应修改。

### AVL树：平衡搜索二叉树

平衡性定义：左树的高度和右树的高度相差绝对值不超过1

#### 什么时候发生左旋和右旋：

当插入节点、删除节点时，每个节点都记住左边，右边的高度。该节点顺着往上找最近的，左右不平衡的树，把该树转平衡即可。

##### RR型调整：插入节点在3，往上发现1是最近的不平衡的。左旋

![img](C:/Users/PennyLiu/AppData/Local/YNote/data/liurqbupt@163.com/9d48fb24acdf4943a5c0375396e89576/clipboard.png)

##### LL型不平衡：右旋

![img](C:/Users/PennyLiu/AppData/Local/YNote/data/liurqbupt@163.com/875233e6bb614fd49d3976b12ac3ba17/clipboard.png)

##### LR型：先左旋，再右旋

![img](C:/Users/PennyLiu/AppData/Local/YNote/data/liurqbupt@163.com/7051ac36f0af4780bce2b96560d83113/clipboard.png)

RL型：

### 红黑树：

平衡性定义：长链的长度不大于短链的2倍

1：每个节点不是红色就是黑色

2：根节点一定是黑色

3：底结点（平时我们叫的叶节点的孩子）一定是黑色

4：每个红结点的子节点一定是黑色

5：任何一个节点的两条链上面的黑节点数量是一样的：两条链的长度不超过2倍

4：SB树（size balance tree）：

平衡性定义：任意一个节点，任何一个叔叔树上节点的数量，都大于其侄子树上的节点数量。竞赛中都用这个了，代码少。

![img](C:/Users/PennyLiu/AppData/Local/YNote/data/liurqbupt@163.com/6b980f4f89b74b02a4f99da7586989ab/clipboard.png)

5：总结

评价：使用起来没什么区别，插入删除复杂度都是O（logN）

不管什么树，任何调整都是两个动作的组合：左旋、右旋。只不过什么时候发生，怎么操作是不一样的。

右旋（顺时针旋）：

![img](C:/Users/PennyLiu/AppData/Local/YNote/data/liurqbupt@163.com/f6d3fa3748434e6c902a4104ea0409ff/clipboard.png)

左旋：

![img](C:/Users/PennyLiu/AppData/Local/YNote/data/liurqbupt@163.com/2bd252c5f72f4b5c9f3d0bd79cfc579b/clipboard.png)

这些树都会继承这个类：AbstractSelfBalancingBinarySearchTree

应用：按加入顺序输出比他大，比他小的那个数。因为有平衡性，所以增删改查都是O(logN)

## 3.找到二叉树中符合搜索二叉树条件的最大拓扑结构

给定一棵二叉树的头节点head，已知所有节点的值都不一样，返回其中最大的且符合搜索二叉树条件的最大拓扑结构的大小

![img](C:/Users/PennyLiu/AppData/Local/YNote/data/liurqbupt@163.com/ac96c383103c4074a5eaa7b42a8204e7/ip_image002.jpeg)

### 思路：

#### 1.搜索二叉树：左子树上所有节点都比头结点小，右子树所有节点都比头大

​     拓扑结构：只要能连上就叫拓扑结构

#### 2.暴力法

以每个节点为头结点，尝试找搜索二叉树的最大拓扑结构。

![img](C:/Users/PennyLiu/AppData/Local/YNote/data/liurqbupt@163.com/6f6c9655be884b8dbe91687abb452403/1505186982%281%29.png)

如上，不包括12 、-1就是以5为头结点的最大拓扑。

按照任何一个遍历的结果，按二叉搜索树的顺序在树中去查找。某个节点不行的话，其子树也不行。

e.g.按照中序遍历的结果是：12  3    4     5     6      7    -1

先找12,12在右子树中没找到，12不算。

找3，找到了

找4，找到了

找6，找到了

找7，找到

找-1，左子树没找到，不算

O（n^2）的复杂度

#### 3.优化

拓扑贡献记录：针对一个特定的结构。

![img](C:/Users/PennyLiu/AppData/Local/YNote/data/liurqbupt@163.com/52c3d5f6ba4f43c48440ab9910a7737f/1505187612%281%29.png)

对于5做头，算贡献：

6,8，2,4节点没有左右子树，能给5提供的贡献是0.

7节点，可以在左子树给5提供1个，右子树提供1个。贡献是2

5节点，可以在左子树给自己提供3个，右子树3个。

![img](C:/Users/PennyLiu/AppData/Local/YNote/data/liurqbupt@163.com/e0bb802f31c946c48f43846963ed02da/1505187838%281%29.png)

对于上图，3的右边也不行。因为7>5.所以3提供给5的也是0个

4：对于叶节点来说，对头提供的都是0个。

对于左右子树，所得到的都是孩子对子树的节点负责的贡献，如果能迅速更新为对上一层的头负责，后序遍历就能知道自己有多少贡献。

![img](C:/Users/PennyLiu/AppData/Local/YNote/data/liurqbupt@163.com/7dbebe79a89b478791304bdf385acd8d/1505190776%281%29.png)

e.g. 如图所示，先分析左子树，右子树同理：

当 5 < 9,5左子树的记录都可以贡献给9

开始分析5的右子树：

右子树上 6 < 9, 6的左子树贡献给9

开始分析6的右子树：

右子树上7 < 9,7的左子树贡献给9

开始分析7的右子树：

右子树上10 > 9,10贡献为0。此时要顺次减去10的贡献

![img](C:/Users/PennyLiu/AppData/Local/YNote/data/liurqbupt@163.com/169a28c792f14ca2b983c5ec98d67b1a/1505190971%281%29.png)

所以在更新的时候，只要更新左子树的右边界和右子树的左边界。每一次更新都记录下来最大值就是最终答案。

e.g.

![img](C:/Users/PennyLiu/AppData/Local/YNote/data/liurqbupt@163.com/c78f2ad2b9bc4380a4db7679853951f6/1505191405%281%29.png)

图上的记录都是给5的贡献，按顺序更新。

![img](C:/Users/PennyLiu/AppData/Local/YNote/data/liurqbupt@163.com/72a9dde06ae64f59ad3572d21a31b062/1505191484%281%29.png)

#### 复杂度分析：

只会遍历左边界或者右边界一次。O(N).