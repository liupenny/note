# 一：count(*)的实现方式

1. MyISAM引擎：把一个表的总行数存在了磁盘上，执行count(*)时直接返回这个数，效率很高；

2. InnoDB引擎：需要把数据一行一行地从引擎里面读出来，然后累积计数。

- **为什么InnoDB不存起来？**

1. 由于多版本并发控制（MVCC）的原因，在同一个时刻的多个查询中，InnoDB应该返回的数都是不确定的

- **InnoDB的实现原理**

1. **在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。**

   所以mysql会找到最小的树来遍历，结果准确，但会导致性能问题。

2. show table status命令：也会显示当前表的行数，但是采样估算的，不准

3. 在数据库保存计数

   - 首先解决了崩溃丢失问题：InnoDB支持crash safe

   - 其次解决了技术精确问题：由于RR，保证逻辑一致

- **不同的count用法**

count()：是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。

分析性能差别时的原则：

1. server层要什么就给什么；
2. InnoDB只给必要的值；
3. 现在的优化器只优化了count(*)的语义为“取行数”，其他“显而易见”的优化并没有做。

即：

**对于count(主键id)来说**，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。

**对于count(1)来说**，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。

单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。

**对于count(字段)来说**：

1. 如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；
2. 如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。

也就是前面的第一条原则，server层要什么字段，InnoDB就返回什么字段。

**但是count(\*)是例外**，并不会把全部字段取出来，而是专门做了优化，不取值。count(*)肯定不是null，按行累加。

- 按照效率排序的话，count(字段)<count(主键id)<count(1)≈count(*)，所以尽量使用count(*)。

# 二：order by的实现原理

MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。

## 全排序：

```
select city,name,age from t where city='杭州' order by name limit 1000  ;
```

假设满足city='杭州’条件的行，是从ID_X到ID_(X+N)的这些记录。执行流程如下所示 ：

1. 初始化sort_buffer，确定放入name、city、age这三个字段；
2. 从索引city找到第一个满足city='杭州’条件的主键id，也就是图中的ID_X；
3. 到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；
4. 从索引city取下一个记录的主键id；
5. 重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；
6. 对sort_buffer中的数据按照字段name做快速排序；
7. 按照排序结果取前1000行返回给客户端。

将这个排序过程，称为全字段排序，

![img](assets/6c821828cddf46670f9d56e126e3e772.jpg)

图中“按name排序”：可能在内存中完成，也可能使用外部排序，取决于排序所需的内存和参数sort_buffer_size。

sort_buffer_size：MySQL为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。否则使用磁盘临时文件辅助排序。

## rowid排序：

- **如果MySQL认为排序的单行长度太大会怎么做？**

此时，MySQL采用另外一种算法。

```
SET max_length_for_sort_data = 16;
```

max_length_for_sort_data：MySQL中专门控制用于排序的行数据的长度的参数。如果单行长度超过该值，单行太大，要换一个算法。

city、name、age 这三个字段的定义总长度是36，将max_length_for_sort_data设置为16，新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id。但这时，排序的结果就因为少了city和age字段的值，不能直接返回了，整个执行流程变为：

1. 初始化sort_buffer，确定放入两个字段，即name和id；
2. 从索引city找到第一个满足city='杭州’条件的主键id，也就是图中的ID_X；
3. 到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；
4. 从索引city取下一个记录的主键id；
5. 重复步骤3、4直到不满足city='杭州’条件为止，也就是图中的ID_Y；
6. 对sort_buffer中的数据按照字段name进行排序；
7. 遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回给客户端。

rowid排序：

![img](assets/dc92b67721171206a302eb679c83e86d.jpg)

## 全字段排序 VS rowid排序

1. MySQL的设计思想：**如果内存够，就要多利用内存，尽量减少磁盘访问。**
2. 对于InnoDB表来说，rowid排序会要求回表多造成磁盘读，因此不会被优先选择。
3. 若创建联合索引，不需要临时表、排序。扫描次数减少

explain时：using index--使用了覆盖索引；using condition index--使用

using filesort：需要排序；Using temporary：需要使用临时表；

## 内存临时表排序

举例：`select word from words order by rand() limit 3;`

流程：当words表不大时：临时内存表排序

临时内存表排序方式的选择：

1. **对于InnoDB表来说**，执行全字段排序会减少磁盘访问，因此会被优先选择
2. **对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，会选择rowid排序**。

临时内存表的rowid排序流程：

1. 创建一个临时表。临时表使用memory引擎，表里有两个字段，第一个字段是double类型，记为字段R，第二个字段是varchar(64)类型，记为字段W。该表没有建索引。
2. 从words表中，按主键顺序取出所有的word值。对于每一个word值，调用rand()函数生成一个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表的R和W字段中，到此，扫描行数是10000。
3. 现在临时表有10000行数据了，接下来你要在这个没有索引的内存临时表上，按照字段R排序。
4. 初始化 sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。
5. 从内存临时表中一行一行地取出R值和**位置信息**，分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加10000，变成了20000。
6. 在sort_buffer中根据R的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。
7. 排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了20003。

![img](assets/2abe849faa7dcad0189b61238b849ffc.png)

**位置信息：**

**MySQL的表是用什么方法来定位“一行数据”的**：rowid

rowid：如果创建的表没有主键，或者把一个表的主键删掉了，那么InnoDB会自己生成一个长度为6字节的rowid来作为主键。即排序模式里rowid名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行的信息。

- 对于有主键的InnoDB表来说，这个rowid就是主键ID；
- 对于没有主键的InnoDB表来说，这个rowid就是由系统生成的；
- MEMORY引擎不是索引组织表。可以认为它就是一个数组，rowid就是数组的下标。

## 磁盘临时表排序

tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大小超过了tmp_table_size，内存临时表就会转成磁盘临时表。

磁盘临时表使用的引擎默认是InnoDB，由参数internal_tmp_disk_storage_engine控制的。

当使用磁盘临时表时，即一个没有显式索引的InnoDB表的排序过程。

排序算法的选择：归并（会使用临时文件）、优先队列（堆排序：不用临时文件）

此时会使用堆排序：因为只需取R值最小的3个rowid。如果使用归并，结果是券都排好序了，浪费。优先队列算法只得到三个最小值。

注：若limit 1000，维护的堆会超内存，就会使用归并。

# 二：逻辑相同，性能差异很大的案例

## 案例一：条件字段函数操作

假设你现在维护了一个交易系统，其中交易记录表tradelog包含交易流水号（tradeid）、交易员id（operator）、交易时间（t_modified）等字段。为了便于描述，我们先忽略其他字段。这个表的建表语句如下：

