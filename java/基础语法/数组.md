# java启动内存

- java在启动时，一共开辟了5片空间进行数据的存储，

①方法区 ②本地方法区  ③寄存器  ④栈内存  ⑤堆内存

| 存储区域 | 存储内容                       | 优点                                               | 缺点                                                         | 回收                                                         |
| -------- | ------------------------------ | -------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 栈       | 基本类型的变量和对象的引用变量 | 存取速度比堆要快，仅次于寄存器，栈数据可以共享     | 存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量 | 当超过变量的作用域后，Java会自动释放掉该变量,内存空间可以立即被另作他用 |
| 堆       | 由new等指令创建的对象和数组    | 可以动态地分配内存大小，生存期也不必事先告诉编译器 | 由于要在运行时动态分配内存，存取速度较慢                     | 由Java虚拟机的自动垃圾回收器来回收不再使用的数据             |

## 栈：数据使用完会自动释放

- 局部变量都在栈内存中：方法中的变量、方法参数、for循环中的变量。
- 栈内存储的除了基本类型的变量（String， int 这种类型的变量）还会存储**对象的引用变量**。

![](https://note.youdao.com/yws/public/resource/3389f2aed228397c99d7c9fd0b4bfe10/xmlnote/094A59E9CEAD422FB6750A6320794324/49658)

### 栈内存使用举例（常量）

```
int a = 5;
int b = a;
b = 8;
// 打印a,还是5；b和a不共用一个地址
```

![](https://note.youdao.com/yws/public/resource/3389f2aed228397c99d7c9fd0b4bfe10/xmlnote/5FB904C459BA46BFBFB9742C2BD4C79D/49666)

## 堆：new 出来的实例都在堆中，包括数组和对象

![](https://note.youdao.com/yws/public/resource/3389f2aed228397c99d7c9fd0b4bfe10/xmlnote/4747B0D9751E41D19875272875684183/49660)

### 给引用变量赋值

回过头再来看代码，实际上里面分解成了四个步骤。

```
Case cc; '''在栈内存里面开辟了空间给引用变量cc，这时cc=null'''
cc=new Case();
'''
1. new Case()在堆内存里面开辟了空间给Case类的对象，这个对象没有名字
2. Case()随即调用了Case类的构造函数
3. 把对象的地址在堆内存的地址给引用变量cc
'''1234567
```

这样我们就明确了：

- Java中，这里的“=”并不是赋值的意思，而是把对象的地址传递给变量；
- 对象创建出来，其实连名字都没有，因此必须通过引用变量来对其进行操作。

### 堆内存的三个特点：

- int[] x = new int[3]. 每个**对象都有地址**；将new 出来的对象地址赋给变量x，称x引用了数组

- 堆内存中的对象都有**默认的初始值**

- x = null; 此时，对象在堆中没有任何引用后，java虚拟机会不定时地启动垃圾回收机制，该内存就被**垃圾回收机制**清除。

  ![](https://note.youdao.com/yws/public/resource/3389f2aed228397c99d7c9fd0b4bfe10/xmlnote/641DAB2F3BDB4DDFAD891B9754342DCF/49662)

### 堆内存使用举例（引用类型特有）

```
int[] x = new int[3];
int[] y = x; //此时，两个引用指向同一个对象
y[1] = 89; // 打印x[1],是89
x = null; // 此时，数组对象还有一个引用。所以打印y[0]还存在，但打印x[0]会有空指针错误
```

![](https://note.youdao.com/yws/public/resource/3389f2aed228397c99d7c9fd0b4bfe10/xmlnote/568E7431D2144D6B8ED3ABA95CE1F819/49664)

# 数组

- 同一种类型数据的集合，其实数组就是一个容器
- int[] x = new int[3].   x是数组类型

## 静态初始化

- int[] arr = new int[]{2,3,4};
- int[] arr = {2,3,4};

## 常见问题

- 编译只检查语法错误，new 是在运行时开辟内存空间，所以数组越界是在运行时才能看到

## 常见操作

### 获取最值

#### 挨个比较

```
public static int getMax(int[] arr){
	// max=0，即max为数组的角标；max = arr[0]即元素
	int max = 0;
	
	for(int i = 1; i < arr.length; i++){
		if(arr[i] > arr[max])
			max = i;
	}
	return arr[max];
}
```

### 排序

```
int[] arr = {2,3,1,4};
sort(arr);
// 这里经过sort就已经拍完序了，（arr和a）（都在栈中）都指向数组对象

public static void sort(int[] a){
    内部对a进行排序
}
```

##### 选择排序：

![](https://note.youdao.com/yws/public/resource/3389f2aed228397c99d7c9fd0b4bfe10/xmlnote/66761E6ADBF049B9A80C36797D1A639F/49678)

对数组的每个位置进行选择，找出应该放在该位置的值。从0开始，拿0位置的元素跟后面所有数比较，找出最小的。

数组从小到大依次归位

##### 冒泡排序：

数组从大到小依次归位

### 数组元素置换

```
public static void(int[] arr, int a, int b){
	int temp = arr[a];
	arr[a] = arr[b];
	arr[b] = temp;
}
```

### 进制转换

#### 十进制--》二进制

![](https://note.youdao.com/yws/public/resource/3389f2aed228397c99d7c9fd0b4bfe10/xmlnote/795D7941BC9C4136A2FFA980B3B95E4B/49684)

##### 简单版本

```
// 十进制--》二进制, 每次除以2所得余数连起来，再反转
// 6/2余0,3/2余1,1/2余1 011翻转110
public static void toBin(int num){
    StringBuffer sb = new StringBuffer();
    // 不能写 > 0, 因为还有负数
    while(num != 0){
		sb.append(num%2);
		num = num/2;
	}
	sb.reverse();
}
```

#### 十进制--》十六进制

![](https://note.youdao.com/yws/public/resource/3389f2aed228397c99d7c9fd0b4bfe10/xmlnote/70B6714A970242B986E1EE91CB6E5BA0/49680)

- 60的二进制：111100

  取最低四位，用 ^15 , 然后右移（>>>）(用无符号右移，否则前面全是1) 4位，再取第二个四位

##### 简单版本

```
public static void toHex(int num){
    StringBuffer sb = new StringBuffer();
	
	for(int x = 0; x < 8; x++){
		int temp = num&15;
		if(temp > 9){
			sb.append((char)(temp - 10 + 'A'));
		}
		else
			sb.append(temp);
		num = num >>> 4;
	}
	sb.reverse();
}
```

##### 查表法--顺序存储：把0--15的值存在char数组（对应关系）中

```
// 如果正着存，不记录pos，会输出很多0，所以用pos
// 如果用数组存结果，会有很多多余的0，所以有效位取完以后就不取了，即循环次数只在有效位内

public static void toHex(int num){
	char[] chs = {'0', ... 'A', ...'F'};
	char[] arr = new char[8];
	int pos = 0；// 正着存，从pos-1开始倒着打印
	
    while(num != 0){
        int temp = num&15;
        arr[pos++] = chs[temp];     
        num = num >>> 4;
	}
	
	// 正着存,就得倒着打印
	for(int i = pos - 1; i >= 0; i--)
		System.out.print(arr[i]);
}
```

##### 查表法--倒着存储

```
public static void toHex(int num){
	char[] chs = {'0', ... 'A', ...'F'};
	char[] arr = new char[8];
	// 在数组中，直接倒着存
	int pos = arr.length;
	
    while(num > 0){
        int temp = num&15;
        arr[--pos] = chs[temp];     
        num = num >>> 4;
	}
	
	// 倒着存的打印
	for(int i = pos; i < arr.length; i++)
		System.out.print(arr[i]);
}
```

#####  学了stringbuffer之后

	// 学了stringbuffer之后
	public static void toHex(int num){
		char[] chs = {'0', ... 'A', ...'F'};
	    StringBuffer sb = new StringBuffer();
	
		// 不能写 num >0, 否则负数没法打印
		// while(num ！= 0)
	    for(int x = 0; x < 8; x++){
	        int temp = num&15;
	        sb.append(chs[temp]);     
	        num = num >>> 4;
		}
		sb.reverse();
	}

#### 统一模板

```
public static void toBin(int num, int base, int offset){
	trans(num,1,1);
}

public static void toHex(int num, int base, int offset){
	trans(num,15,4);
}

public static void trans(int num, int base, int offset)
{
	if(num == 0){
		print(0);
		return;
	}
    char[] chs = {'0', ... 'A', ...'F'};
    char[] arr = new char[32];
    int pos = arr.length;
    
    while(num != 0){
        int temp = num&base;
        arr[--pos] = chs[temp];     
        num = num >>> offset;
	}
	
	for(int i = pos; i < arr.length; i++){
        System.out.print(arr[i]);
	}
}
```

## 二维数组

### 地址分配

```
// 此时二维数组所有元素都创建了
int[][] arr = new int[3][4];
print(arr) // [[ +地址 （2个[标明是二维数组）
print(arr[0]) // [ +地址 （1个[标明是二维数组）
```

![](https://note.youdao.com/yws/public/resource/3389f2aed228397c99d7c9fd0b4bfe10/xmlnote/4703F436D7734EBF911BFF0DCEEDEEEF/49688)

```
// 只创建好了二维数组的三个指针，每个一维都没创建
int[][] arr = new int[3][];
print(arr[0]) // 打印出来是 null ，需要对每一维手动创建
```

![](https://note.youdao.com/yws/public/resource/3389f2aed228397c99d7c9fd0b4bfe10/xmlnote/C237BDB1704B43C89F260958853BC370/49686)

### 声明&初始化

```java
int[][] arr;
int arr[][];
int[] arr[];
```

