# 函数

## 函数定义

- 主函数就负责调用函数
- 明确函数的运算结果，输入参数
- 每个函数只实现一个功能，打印功能放在一个函数内实现
- 语句都写在函数内

```
// 判断两个数是否相等
Public statis boolean isSame(int a, int b){
	// 1. 考虑比较运算
	return a == b;
	// 2. 三元运算符
	return a == b ? true : false;
}
```

## 函数的重载(overload)

- 定义：在同一个类中，可以存在一个以上的同名函数，只要他们的参数个数或者参数类型不同即可。和返回值无关

```
// 提高代码复用性，在这里是打印9*9
public static void print99(){
	// 直接调用已经写好的即可
	print99(9);
}

// 这里是打印乘法表中到给定数的那一行
public static void print99(int num){
	for(int i = 1; i <= num; i++)
		for(int j = 1; j <= i; j ++)
		{
            System.out.println(i*j);
		}
}
```

# 修饰符

## final

final可以修饰：属性，方法，类，局部变量（方法中的变量）

- final修饰的属性的初始化可以在编译期，也可以在运行期，初始化后不能被改变。
- final修饰的属性跟具体对象有关，在运行期初始化的final属性，不同对象可以有不同的值。
- final修饰的属性表明是一个常数（创建后不能被修改）。
- final修饰的方法表示该方法在子类中不能被重写，final修饰的类表示该类不能被继承。

对于基本类型数据，final会将值变为一个常数（创建后不能被修改）；但是对于对象句柄（亦可称作引用或者指针），final会将句柄变为一个常数（进行声明时，必须将句柄初始化到一个具体的对象。而且不能再将句柄指向另一个对象。但是，对象的本身是可以修改的。这一限制也适用于数组，数组也属于对象，数组本身也是可以修改的。方法参数中的final句柄，意味着在该方法内部，我们不能改变参数句柄指向的实际东西，也就是说在方法内部不能给形参句柄再另外赋值）。

## static

static可以修饰：属性，方法，代码段，内部类（静态内部类或嵌套内部类）

- static修饰的属性的初始化在编译期（类加载的时候），初始化后能改变。
- static修饰的属性所有对象都只有一个值。
- static修饰的属性强调它们只有一个。
- static修饰的属性、方法、代码段跟该类的具体对象无关，不创建对象也能调用static修饰的属性、方法等
- static和this，super势不两立，static跟具体对象无关，而this、super正好跟具体对象有关。
- static不可以修饰局部变量。

[java中static、final、static final的区别](http://blog.csdn.net/qq1623267754/article/details/36190715)

## 权限修饰符

### 定义

- public：可以被所有其他类所访问

  具有最大的访问权限，可以访问任何一个在classpath下的类、接口、异常等。它往往用于对外的情况，也就是对象或类对外的一种接口的形式

- protected：自身、子类及同一个包中类可以访问

  主要的作用就是用来保护子类的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西

- default：同一包中的类可以访问，声明时没有加修饰符，认为是friendly

  有时候也称为friendly，它是针对本包访问而设计的，任何处于本包下的类、接口、异常等，都可以相互访问，即使是父类没有用protected修饰的成员也可以

- private：只能被自己访问和修改

  访问权限仅限于类的内部，是一种封装的体现，例如，大多数成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问

|           | 类内部 | 本包  | 子类  | 外部包 |
| --------- | ------ | ----- | ----- | ------ |
| public    | True   | True  | True  | True   |
| protected | True   | True  | True  | False  |
| default   | True   | True  | False | False  |
| private   | True   | False | False | False  |

> 注意：java的访问控制是停留在编译层的，也就是它不会在.class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。其实，通过反射的手段，是可以访问任何包下任何类中的成员，访问类的私有成员也是可能的。

### 通过反射调用访问private变量和方法

例如

```java
public class Exam{  
    private String field1="私有属性";  
    public String field2="公有属性";  
    public void fun1(){  
        System.out.println("fun1:这是一个public访问权限方法");  
    }  

    private void fun2(){  
        System.out.println("fun2:这是一个private访问权限方法");  
    }  

    private void fun3(String arg){  
        System.out.println("fun3:这是一个private访问权限且带参数的方法，参数为："+arg);  
    }  
}  
```

在将Exam.java编译为class文件后，通过反射调用访问private变量和方法

```java
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class Test02 {
    public static void main(String args[]){
        Exam e = new Exam();
        try {
            Field field1 = e.getClass().getDeclaredField("field1");
            Field field2 = e.getClass().getDeclaredField("field2");
            field1.setAccessible(true);
            System.out.println("field1: "+field1.get(e));
            field1.set(e,"重新设置一个field1值");
            System.out.println("field1: "+field1.get(e));
            System.out.println("field2: "+field2.get(e));
            field2.set(e,"重新设置一个field2值");
            System.out.println("field2: "+field2.get(e));
        } catch (NoSuchFieldException e1) {
            e1.printStackTrace();
        }catch (IllegalArgumentException e1) {
            e1.printStackTrace();
        } catch (IllegalAccessException e1) {
            e1.printStackTrace();
        }

        try {

            Method method1 = e.getClass().getDeclaredMethod("fun1");
            method1.invoke(e);

            Method method2 = e.getClass().getDeclaredMethod("fun2");
            method2.setAccessible(true);
            method2.invoke(e);

            Method method3 = e.getClass().getDeclaredMethod("fun3",String.class);
            method3.setAccessible(true);
            method3.invoke(e,"fun3的参数");
        } catch (NoSuchMethodException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        } catch (SecurityException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        }catch (IllegalAccessException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        } catch (IllegalArgumentException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        } catch (InvocationTargetException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        }
    }
}
```

运行结果为

[java利用反射访问类的私有(private)属性及方法](http://blog.csdn.net/codefunjava/article/details/39718843)

### 如何防止被反射调用

通过调用堆栈判断

```java
class Dummy {
    private void safeMethod() {
        StackTraceElement[] st = new Exception().getStackTrace();
        // If a method was invoked by reflection, the stack trace would be similar
        // to something like this:
        /*
        java.lang.Exception
            at package1.b.Dummy.safeMethod(SomeClass.java:38)
            at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
            at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
            at sun.reflect.16qcsLhcYm4NdG4fVkW2mwfDB8kwpPsYCq.invoke(16qcsLhcYm4NdG4fVkW2mwfDB8kwpPsYCq.java:43)
        ->    at java.lang.reflect.Method.invoke(Method.java:601)
            at package1.b.Test.main(SomeClass.java:65)
        */
        //5th line marked by "->" is interesting one so I will try to use that info

        if (st.length > 5 &&
            st[4].getClassName().equals("java.lang.reflect.Method"))
            throw new RuntimeException("safeMethod() is accessible only by Dummy object");

        // Now normal code of method
        System.out.println("code of safe method");
    }

    // I will check if it is possible to normally use that method inside this class
    public void trySafeMethod(){
        safeMethod();
    }

    Dummy() {
        safeMethod();
    }
}

class Dummy1 extends Dummy {}

class Test {
    public static void main(String[] args) throws Exception {
        Dummy1 d1 = new Dummy1(); // safeMethod can be invoked inside a superclass constructor
        d1.trySafeMethod(); // safeMethod can be invoked inside other Dummy class methods
        System.out.println("-------------------");

        // Let's check if it is possible to invoke it via reflection
        Method m2 = Dummy.class.getDeclaredMethod("safeMethod");
        // m.invoke(d);//exception java.lang.IllegalAccessException
        m2.setAccessible(true);
        m2.invoke(d1);
    }
}
```

```shell
code of safe method
code of safe method
-------------------
Exception in thread "main" java.lang.reflect.InvocationTargetException
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.16qcsLhcYm4NdG4fVkW2mwfDB8kwpPsYCq.invoke(16qcsLhcYm4NdG4fVkW2mwfDB8kwpPsYCq.java:43)
    at java.lang.reflect.Method.invoke(Method.java:601)
    at package1.b.Test.main(MyClass2.java:87)
    Caused by: java.lang.RuntimeException: method safeMethod() is accessible only by Dummy object
    at package1.b.Dummy.safeMethod(MyClass2.java:54)
    ... 5 more
```

[How do I access private methods and private data members via reflection?](https://stackoverflow.com/questions/11483647/how-do-i-access-private-methods-and-private-data-members-via-reflection)

# 尾递归

最简单的递归形式是把递归调用语句放在函数结尾即恰在return语句之前。这种形式被称作尾递归或者结尾递归，因为递归调用出现在函数尾部。由于尾递归的作用相当于一条循环语句，所以它是最简单的递归形式

对于“尾递归”的情况，也就是说函数体中用到的变量不需要栈保存，是可以进行优化的，会将其展开成循环，但如果递归函数中有分支就不行，比如路径遍历的实现。有分支就要保存条件变量，就需要压栈