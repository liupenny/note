# 一、final

​       final可以修饰**非抽象类**、**非抽象类成员方法和变量**、不能用于修饰构造方法

## final类：

1. 不能被继承，
2. final类中的方法默认是final的。注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。 

## final方法：

1. 不能被子类的方法覆盖，但可以被继承。
2. 编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。

## final变量：

1. 表示常量，只能被赋值一次，赋值后值不再改变。   
2. final修饰的变量有三种：静态变量、实例变量和局部变量，先声明，而不给初值



# **二、static**

​        static用来修饰成员变量、成员方法，静态代码块，静态内部类

## static变量：

1. 被static修饰的叫做静态变量，没有被static修饰的变量，叫实例变量。
2. 静态变量在内存中只有一份，jvm在类加载阶段将变量分配在方法区并内赋值。
3. 实例变量，每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响。
4. static变量前有private修饰时：不能在其他类中通过类名来直接引用。private是访问权限限定，static表示不要实例化就可以使用

## 静态方法：

1. 静态方法可以直接通过类名调用，任何的实例也都可以调用，静态方法中不能用this和super关键字，
2. 不能直接访问所属类的实例变量和实例方法(就是不带static的），只能访问所属类的静态成员变量和成员方法。
3. static方法独立于任何实例，所以static方法必须被实现，而不能是抽象的abstract。

## 静态代码块：

1.  static代码块，在类中独立于类成员，可以有多个，位置随便放
2. 当Java虚拟机（JVM）加载类时，就会按照它们在类中出现的先后顺序依次执行。
3. static和final一块用表示什么？
   **static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！**
   - 对于变量，表示一旦给值就不可修改，并且通过类名可以访问。
   - 对于方法，表示不可覆盖，并且可以通过类名直接访问。

​        **特别要注意一个问题：**

​        对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，这一点在编程中用到很多。 
