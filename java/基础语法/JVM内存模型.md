# JAVA内存模型

**JDK1.8之前：**

![img](.\assets\68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67.png)

**运行时数据区域**

![è¿éåå¾çæè¿°](D:/Liurq/Documents/note/java/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/assets/20180102165046608.png) 

**JDK1.8**

![img](.\assets\68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d334a617661e8bf90e8a18ce697b6e695b0e68daee58cbae59f9f4a444b312e382e706e67.png)

## 1.程序计数器

1. 程序计数器`（Program Counter Register）`是一块较小的内存空间：当前线程所执行的字节码的行号指示器。

   字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

2. 字节码指令、分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。

3. 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。

4. 此内存区域是唯一一个在Java虚拟机中没有规范任何`OutOfMemoryError`情况的区域。

## 2.Java虚拟机栈

1. Java虚拟机栈也是线程私有的，它的生命周期与线程相同，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个 栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java 虚拟机 不要求栈帧在内存空间里连续分布。每当函数调用结束后，会有一个栈帧被弹出。java有两种返回方式：1. return  2. 抛出异常
2. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常；如果虚拟机栈可以动态扩展，且扩展时无法申请到足够的内存，就会抛出`OutOfMemoryError`异常；（当前大部分JVM都可以动态扩展，只不过JVM规范也允许固定长度的虚拟机栈）
3. Java虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时会创建一个栈帧。 

### 栈帧

- 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧用于存储**局部变量表、操作数栈、动态链接、方法返回**等信息。 每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 
- 在活动线程中，只有位于栈顶的栈帧才是有效的，称为**当前栈帧**，与这个栈帧相关联的方法称为**当前方法**。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。

![è¿éåå¾çæè¿°](D:/Liurq/Documents/note/java/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/assets/20180102180455895.png) 



局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)「String是引用类型」，对象引用(reference类型)和returnAddress类型（它指向了一条字节码指令的地址） 

1. 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
2. 但是，如果是成员变量，或者定义在方法外对象的引用，它们存储在堆中。因为在堆中，是线程共享数据的，并且栈帧里的命名就已经清楚的划分了界限 : 局部变量表！

## 3.本地方法栈

1. 本地方法栈`（Native Method Stack）`与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务（也就是字节码）服务，而本地方法栈为虚拟机使用到的Native方法服务。
2. Java虚拟机规范对本地方法栈使用的语言、使用方法与数据结构并没有强制规定，因此可以由虚拟机自由实现。例如：HotSpot虚拟机直接将本地方法栈和虚拟机栈合二为一。
3. 同虚拟机栈相同，Java虚拟机规范对这个区域也规定了两种异常情况`StackOverflowError` 和` OutOfMemoryError`异常。

## 4.堆

1. Java堆是被**所有线程**共享的一块内存区域，在虚拟机启动时创建，是虚拟机所管理的内存中最大的一块。此内存区域的唯一目的就是**【存放对象实例和数组】**，几乎所有的对象实例和数组都在这里分配内存。
2. **Java堆是垃圾收集器管理的主要区域，也称为GC 垃圾堆**。
   - 从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆可以细分为：新生代、老生代； 
   - 从内存分配的角度看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区（TLAB）； 
   - 不论如何划分，都与存放的内容无关，无论哪个区域，存储的仍然是对象实例和数组。
3. 如果在堆中没有内存完成实例分配，并且堆上也无法再扩展时，将会抛出`OutOfMemoryError`异常。
4. 内存泄露和内存溢出 
   **内存泄露 ：** 指程序中动态分配内存给一些临时对象，但是对象不会被GC所回收，它始终占用内存。即被分配的对象可达但已无用，可用内存越来越少。 
   **内存溢出 ：** 指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于老年代或永久代垃圾回收后，仍然无内存空间容纳新的Java对象的情况。 
   **内存泄露是内存溢出的一种诱因，不是唯一因素。**

### 堆外内存

**1.堆内内存：**Java中的对象都是在JVM堆中分配的，在jvm参数中只要使用-Xms，-Xmx等参数就可以设置堆的大小和最大值，理解jvm的堆还需要知道下面这个公式：

```
堆内内存 = 新生代+老年代+持久代
```

其**好处**在于开发者不用关心对象的回收。但有利必有弊，堆内内存主要有两个**缺点**：1.GC是有成本的，堆中的对象数量越多，GC的开销也会越大。2.使用堆内内存进行文件、网络的IO时，JVM会使用堆外内存做一次额外的中转，也就是会多一次内存拷贝。

**2.堆外内存：**和堆内内存相对应，堆外内存就是把内存对象分配在Java虚拟机堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。用java.nio.DirectByteBuffer对象进行堆外内存的管理和使用，它会在对象创建的时候就分配堆外内存。DirectByteBuffer类是在Java Heap外分配内存，对堆外内存的申请主要是通过成员变量unsafe来操作。

**使用堆外内存的优点**

1、减少了垃圾回收
因为垃圾回收会暂停其他的工作。

2、加快了复制的速度
堆内在flush到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略掉了这个工作。

同样任何一个事物使用起来有优点就会有缺点，堆外内存的缺点就是内存难以控制，使用了堆外内存就间接失去了JVM管理内存的可行性，改由自己来管理，当发生内存溢出时排查起来非常困难。

## 5.方法区

1. 方法区又被称为静态区，是程序中永远唯一的元素存储区域。和堆一样，是各个线程共享的内存区域。它**用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。**
2. Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样 不需要连续的内存和可以选择固定大小或者可扩展之外，还**可以选择不实现垃圾回收。** 
   这区域的内存回收目标主要是针对常量池的回收和类型的卸载，一般而言，这个区域的内存回收比较难以令人满意，尤其是类型的回收，条件相当苛刻，但是这部分区域的内存回收确实是必要的。
3. 很多开发者更愿意把方法区称为“永久代”(Perm Gen)(Permanent Generation)「**总是存放不会轻易改变的内容」**。在目前已经发布的JDK 1.7 的HotSpot中，已经把原本放在永久代的字符串常量池移至堆中。
4. 运行时常量池(Runtime Constant Pool)是方法区的一部分。

> JDK 1.8 中，已经没有方法区(永久代)，而是将方法区直接放在一个与堆不相连的本地内存区域(Native Memory)，这个区域被叫做元空间。

### 运行时常量池

1. Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(Constant Pool Table)，用于存放**编译期生成的字面量和符号引用**，这部分内容（也可以称为 .Class文件中的静态常量池）将在类加载后进入方法区的运行时常量池中存放。

   - 字面量 ： 比较接近Java语言层面的常量概念，如文本字符串、声明为final的常量值等。（final修饰的成员变量和类变量！「类变量即静态(成员)变量)」，也就是除final修饰的局部变量。

   - 符号引用 ： java编译器**编译后**（因为编译会对源码优化）出现的各种类。包括 

     1. 类和接口的全限定名(即路径，包名+类名)。 
     2. 字段的名称和描述符。 
     3. 方法的名称和描述符。 

     当虚拟机运行时，需要从常量池获得对应的符号引号，再在类创建或运行时解析、翻译到具体的内存地址之中（直接引用）。

2. 除了保存Class文件中描述的符号引用外，还会把编译出来的直接引用也存储在运行时常量池中。

3. Java语言并不要求常量一定只有编译期才能生成，也就是并非置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String 类的intern()方法。

   intern方法：当string对象s调用intern时(`s.intern()`），如果运行时常量池中有s的值，则直接返回该字符串在运行时常量池的地址；**如果不存在s的值，则将s的地址（引用）存放在运行时常量池，并返回s的地址（引用）。** 

4. 当常量池无法再申请到内存时也会抛出`OutofMemoryError`异常。

### Hotspot实现

在hotsopt中，使用永久代实现方法区。JDK1.8时，方法区就被彻底移除，使用元空间，即直接内存。

为什么？

整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到 java.lang.OutOfMemoryError。可以使用 `-XX：MaxMetaspaceSize` 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。`-XX：MetaspaceSize` 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

## 6.直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。

JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。

本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

## 拓展：成员变量与局部变量

- 成员变量 : 方法外部，类内部定义的变量；
- 局部变量 : 方法或语句块内部定义的变量，必须初始化。

形参是局部变量，实参则可能是方法中的局部变量或全局变量。 
栈内存中的局部变量随方法而生，随方法而灭。 
成员变量存储在堆中的对象里，由垃圾收集器回收。

| 定义     | 成员变量       | 局部变量           | 静态变量                             |
| -------- | -------------- | ------------------ | ------------------------------------ |
| 定义位置 | 在类中，方法外 | 方法中，或形参     | 类中，方法外（java只有静态成员变量） |
| 初始化值 | 有默认初始化值 | 无，先定义，后赋值 | 默认初始化值                         |
| 存储位置 | 堆             | 栈                 | 方法区                               |
| 声明周期 | 与对象共存亡   | 与方法(线程)共存亡 | 与类共存亡                           |
| 别名     | 实例变量       |                    | 类变量                               |

# 注解

Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到**说明、配置**的功能
注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。

## 说明：

jdk5之后提供了一个特性,和类 接口同级

- 格式:

  @interface 注解名{}

- 作用:

1. 编译检查
2. 替代配置文件
3. 定义注解(元注解:注解上的注解，决定注解的位置-放在方法上或者类上)
4. 分析代码(什么时候执行，怎么执行--用到反射)

- 注解属性:

1. 注解本质就是一个接口(可以用javap命令反编译去看),接口中可以有常量和抽象方法(public abstract)
2. 抽象方法在注解中就称之为注解属性

- 注解属性类型有限制:

```
基本类型
String
Class
Annotation
Enum:枚举(构造方法私有了，只能使用其内部的对象)
以上类型对应的一维数组
```

- 注意:

  一旦注解有属性了,使用注解的时候必须赋值,(除非这个注解属性有默认值)	

  赋值的格式:
  ​    @注解名(属性名=属性值)
  ​    若注解类型为数组,且只有一个值的时候,可以有两种写法
  ​        方式1:
  ​            属性名 = { 值 } e.g. @MyAnno(ss = {"que","123"})
  ​        方式2:
  ​            属性名=属性值  e.g. @MyAnno(ss = "que")
  ​    若属性名为value的时候,且只有这一个value属性，只需要为这个value属性赋值的时候,value可以省略

- 元注解:(理解)

  定义在注解上的注解

1. @Retention  规定注解保留到什么阶段(生命周期)  值为RetentionPolicy的三个枚举值

```
SOURCE:只在代码中保留,在字节码文件中就删除了。(默认是源码阶段)
CLASS:在代码和字节码文件中保留。在编译期检查
RUNTIME:所有阶段都保留。当配置文件用		
```

1. @Target 规定注解作用在什么上面 	值为ElementType的枚举值

```
TYPE:作用在类 接口 等上面
METHOD:作用方法上面
FIELD:作用字段上面

e.g.
@Target(ElementType.METHOD)
public @interface MyAnnotation4 {	
}
```

## 分类

### 按运行机制划分

- 源码注解：只在源码中存在，编译成.class文件就不存在了
- 编译时注解：在源码和.class文件中都存在。像前面的`@Override`、`@Deprecated`、`@SuppressWarnings`，他们都属于编译时注解
- 运行时注解：在运行阶段还起作用，甚至会影响运行逻辑的注解。像`@Autowired`自动注入的这样一种注解就属于运行时注解，它会在程序运行的时候把你的成员变量自动的注入进来

### 按来源划分

- JDK注解

  - `@Override`：告诉用户和编译器该方法覆盖了父类中的同一个方法
  - `@Deprecated`：表明这个方法已经过时了，会发出警告
  - `@Suppvisewarnings("xxx")`：表示忽略了xxx的警告

- 第三方注解

  例如Spring的`@Autowired`，`@Service`，Mybatis的`@InsertProvider`，`@Options`等

- 自定义注解

### 元注解

元注解是给注解进行注解，可以理解为注解的注解就是元注解

## 自定义注解

使用`@interface`关键字定义一个注解

```java
// 元注解部分
@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented

// 注解部分
public @interface Description {
    String desc();
    String author();
    int age() default 18;
}
```

其中定义的“方法”在注解里只是一个成员变量，可以用`default`指定默认值

- 成员类型是受限制的，合法的类型包括基本的数据类型以及String，Class，Annotation,Enumeration等。
- 如果注解只有一个成员，则成员名必须取名为`value()`，在使用时可以忽略成员名和赋值号（=）。
- 注解类可以没有成员，没有成员的注解称为标识注解。

元注解部分说明：

- `@Target`：作用域列表，格式为`ElementType.xxx`，中间用逗号分隔
  - `METHOD`：方法声明
    - `CONSTRUCTOR`：构造方法声明
    - `FIELD`：字段声明
    - `LOCAL VARIABLE`：局部变量声明
    - `METHOD`：方法声明
    - `PACKAGE`：包声明
    - `PARAMETER`：参数声明
    - `TYPE`：类接口
- `@Retention`：生命周期
  - `RUNTIME`在运行时存在，可以通过反射读取
    - `SOURCE`：只在源码显示，编译时丢弃
    - `CLASS`：编译时记录到class中，运行时忽略
- `@Inherited`是一个标识性的元注解，它允许子注解继承它。
- `@Documented`，生成javadoc时会包含注解

使用自定义注解：`@<注解名>(<成员名1>=<成员值1>,<成员名1>=<成员值1>,…)`

```java
@Description(desc="i am Color",author="boy",age=18)
public String Color() {
    return "red";
}
```

## 解析注解

通过反射获取类 、函数或成员上的**运行时注解信息**，从而实现动态控制程序运行的逻辑。

```java
@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Description {
    String value();
}

@Description("Class Annotation")
public class Child {
    @Override
    @Description("Method Annotation")
    public String name() {
        return null;
    }
}

public static void main(String[] args) {
    try {
        // 使用类加载器加载类
        Class c = Class.forName("com.test.Child");
        // 找到类上面的注解
        boolean isExist = c.isAnnotationPresent(Description.class);
        // 上面的这个方法是用这个类来判断这个类是否存在Description这样的一个注解
        if (isExist) {
            // 拿到注解实例，解析类上面的注解
            Description d = (Description) c.getAnnotation(Description.class);
            System.out.println(d.value());
        }

        //获取所有的方法
        Method[] ms = c.getMethods();
        for (Method m : ms) {
            //拿到方法上的所有的注解
            Annotation[] as = m.getAnnotations();
            for (Annotation a : as) {
                //用二元操作符判断a是否是Description的实例
                if (a instanceof Description) {
                    Description d = (Description) a;
                    System.out.println(d.value());
                }

            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

输出

```shell
Class Annotation
Method Annotation
```

[框架开发之Java注解的妙用](https://www.jianshu.com/p/b560b30726d4)

# 内存泄漏

**内存泄漏**：对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着。
在Java中，**内存泄漏**就是存在一些被分配的对象，这些对象有下面两个特点，**首先**，这些对象是可达的，即**在有向图中，存在通路可以与其相连**；**其次**，**这些对象是无用的，即程序以后不会再使用这些对象**。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。

根本原因：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是**因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景**。

判断一个内存空间是否符合垃圾收集的标准有两个：**一个是给对象赋予了空值null，以下再没有调用过另一个是给对象赋予了新值，这样重新分配了内存空间**。

![img](.\assets\2827798-eac74f6058065a09.webp)

## 原因：

1. 静态集合类引起内存泄漏

给出一个 Java 内存泄漏的典型例子

```
Vector v = new Vector(10);

for (int i = 0; i < 100; i++) {
    Object o = new Object();
    v.add(o);
    o = null;
}
```

在这个例子中，我们循环申请Object对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。

`v = null`

2. 监听器

在 **java** 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如**addXXXListener()** 等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。

3. 各种连接池

比如数据库连接（**dataSourse.getConnection()**），网络连接(**socket**)和**io**连接，除非其显式的调用了其**close()** 方法将其连接关闭，否则是不会自动被**GC** 回收的。对于**Resultset** 和**Statement** 对象可以不进行显式回收，但**Connection** 一定要显式回收，因为**Connection** 在任何时候都无法自动回收，而**Connection**一旦回收，**Resultset** 和**Statement** 对象就会立即为**NULL**。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭**Resultset Statement** 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的**Statement** 对象无法释放，从而引起内存泄漏。这种情况下一般都会在**try** 里面去的连接，在**finally**里面释放连接。

4. 内部类和外部模块的引用

内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：

```
public void registerMsg(Object b);
```

这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B是否提供相应的操作去除引用。

5. 单例模式

不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在 **JVM** 的整个生命周期中存在（**以静态变量的方式**），如果单例对象持有外部的引用，那么这个对象将不能被 **JVM** 正常回收，导致内存泄漏，考虑下面的例子：

```java
public class A {
    public A() {
        B.getInstance().setA(this);
    }
    ...
}

//B类采用单例模式
class B{
    private A a;
    private static B instance = new B();
    
    public B(){}
    
    public static B getInstance() {
        return instance;
    }
    
    public void setA(A a) {
        this.a = a;
    }

    public A getA() {
        return a;
    }
}
```

