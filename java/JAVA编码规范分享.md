# JAVA编码规范分享

## 安全规约

1. 水平权限攻击 & 垂直权限攻击

   1. **垂直权限管理**
     基于角色的权限管理（RBAC模型），又称为“垂直权限管理”。不同角色的权限有高低之分。高权限角色访问低权限角色的资源往往是被允许的，而低权限角色访问高权限角色的资源往往是被拒绝的。如果低权限角色获得了高权限角色的能力，那么就发生了“越权访问”

     **问题举例：** web应用没有做权限控制，恶意公户猜到了其他页面的url，就会控制其他角色拥有的页面（管理员页面）

     **解决：** 对url进行权限验证

   2. **水平权限管理**
     A与B具有相同的角色，如果A可以访问B的资源，那么就发生了越权访问。这种问题就是“水平权限管理问题”。

     **问题举例：**userA获取删除评论的url，在表单参数中写入评论编号，程序没有对评论的所有者和url中传来的参数userid做比较，就在数据库中修改对应数据。

     **解决：** CURD的时候判断请求者与数据拥有者是否一致

2. 参数绑定

   **sql注入：**用户名密码登录验证：String sql = " select * from login where name=' " +name+ " ' and pwd = ' " +pwd+ " ' ";

   ​           这时候如果用户输入的密码是 ' or '1' = '1 ，整条输出语句可以拼装为 select * from login where name='xx' and pwd =' ' or '1' = '1'

    

   **使用PreparedStatement 就可以防止sql注入方式是因为它进行了循环遍历:**

   ​          首先这个类进行语句执行不是直接进行语句的拼接，而是先进行预编译，用? 进行占位再set()的时候将属性左右加上' (int类型不会)  

   ​          然后会把用户输入的所有字符集全部遍历如果识别出一些特殊字符比如 换行符、\ 、双引号、单引号还有一些特殊字符会进行编译

   ​          比如还是输入刚才的密码 会变成 select * from login where name='xx' and pwd =' \' or \'1\' = \'1\' '   

   ​          所以使用了PreparedStatement 就无法截断SQL语句，也就是说 无法拼接SQL语句，防止了sql注入。

3. 反序列化注入

   原理：恶意攻击者可能也可以构建特定的输入，在 ObjectInputStream类反序列化之后会产生非正常结果，利用这一方法就可以实现远程执行任意代码。

   漏洞的根本问题：其实并不是Java序列化的问题，而是Apache Commons Collections允许链式的任意的类函数反射调用。攻击者通过允许Java序列化协议的端口，把攻击代码上传到服务器上，再由Apache Commons Collections里的TransformedMap来执行。

   解决：如果可以禁止JVM执行外部命令，未知漏洞的危害性会大大降低，可以大大提高JVM的安全性。

## MySQL数据库

## 1.建表规约（小写、无数字开头）

- 库：与应用名字一致

- 表：业务名_表的作用、不用复数名词

必备字段：

1. id
2. 创建日期
3. 最近修改日期

索引字段：pk_xxx / uk_xxx / idx

- 字段：小写、下划线之间不能只有数字、

1. 是否概念：is_xxx，
2. 小数用decimal保存，超出精度将整数、小数部分分开保存
3. varchar不用预先分配空间，超过5000用text；

- 分库分表

  **分库分表的顺序应该是先垂直分，后水平分。** 因为垂直分更简单，更符合我们处理现实世界问题的方式。

  - 垂直拆分

  1. 垂直分表

     也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。 一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。

  2. 垂直分库

     垂直分库针对的是一个系统中的不同业务进行拆分，比如用户User一个库，商品Producet一个库，订单Order一个库。 切分后，要放在多个服务器上，而不是一个服务器上。

  - 水平拆分

  1. 水平分表

     针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。不建议采用。

  2. 水平分库分表

     将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。

## 2.索引规约

1. varchar上指定长度：减少索引大小，加快速度

2. 索引的有序性：不用再次排序。file_sort：

3. 回表：

   什么是回表？

   简单来说就是数据库根据索引找到了指定的记录所在行后，还需要根据rowid再次到数据块里取数据的操作。（e.g. 非聚簇索引-索引与行记录是分开的）
   比如这样的执行计划，先索引扫描，再通过rowid去取索引中未能提供的数据，即为回表。
   “回表”一般就是指执行计划里显示的“TABLE ACCESS BY INDEX ROWID”。
   再例如，虽然只查询索引里的列，但是需要回表过滤掉其他行。
   怎么避免回表？

   将需要的字段放在索引中去。查询的时候就能避免回表。

4. 延迟关联：

   何谓"延迟关联" ：通过使用覆盖索引查询返回需要的主键,再根据主键关联原表获得需要的数据。

5. order by的实现方式

   1. 利用有序索引自动实现：只有当order by 字段出现在where条件中时，才会利用索引而无需排序操作

      这个结论不仅对order by有效，对其他需要排序的操作也有效。比如group by 、union 、distinct等。 

   2. 把结果选好之后再排序

6. 一条SQL实际上可以分为三步

   1.得到数据 

   2.处理数据 

   3.返回处理后的数据 

**e.g.** 比如上面的这条语句select sid from zhuyuehua.student where sid < 50000 and id < 50000 order by id desc 

第一步：根据where条件和统计信息生成执行计划，得到数据。 

第二步：将得到的数据排序。 

当执行处理数据（order by）时，数据库会先查看第一步的执行计划，看order by 的字段是否在执行计划中利用了索引。如果是，则可以利用索引顺序而直接取得已经排好序的数据。如果不是，则排序操作。 

第三步：返回排序后的数据。 

## 3.

pojo中：布尔类型变量不加is， getter setter的变量不加get,set