# 设计模式

## 定义

解决某一类问题最行之有效的抽象方案，共23种，是一种思想。模式的综合使用即为框架。

# 单例设计模式：解决一个类在内存中只存在一个对象

## 情景：

A程序：读软件的配置文件，进行修改

B程序：读软件的配置文件，进行修改

如果A，B都new 一个新的配置文件对象，那A,B对配置文件的修改没关系

所以要求内存中只有一个配置文件对象，A,B都修改他

## 思想：

1：为了避免其他程序过多建立该类对象，先禁止其他程序建立该类对象

2：为了其他程序访问到该类对象，只好在本类中，自定义一个对象

3：为了方便其他程序对自定义对象的访问，可以对外提供一些访问方式。

## 如何用代码体现：

1：将构造函数私有化

2：在类中创建一个本类对象

3：提供一个方法可以获取到该对象

- 如果是public getInstance方法，需要new 对象才能访问，现在不能new对象，所以改成static方法
- 因为静态方法访问静态变量，所以s也应该是static的
- 因为s是内部保护的，所以设置成private

```
class Single
{
    private Single(){
    }
    
    private static Single s = new Single();
    public static Single getInstance(){
        return s;
    }
}

class SingleDemo
{
    public static void main()
    {
        Single ss = Single.getInstance();
        //Single s1 = Single.getInstance();
    }
}
```

- single类一加载，s在方法区中，此时要new 对象，该对象在堆中开辟空间，将堆地址给s。

- 再将s的值给ss，

- s1也指向同一个对象

- 此时这个对象有三个引用：s, ss, s1

  ![](https://note.youdao.com/yws/public/resource/f2168540caf26c25109a3234bac42594/xmlnote/691D3FB90CBD4DAAB9FF2EC06C67E0EE/49740)

## 应用：

对于该事物该怎么描述就怎么描述（对象变量），当需要该事物的对象在内存中唯一时，就将以上三步加上即可

```
class Student
{
    private int age;
    // 加三步
    private static Student a = new Student();
    private Student(){};
    public static Student getStudenr(){
        return s;
    }
    
    // 这些都是对象的其他描述
    public void setAge(int age){
		this.age = age;
	}
	
	public int getAge(){
        return age;
	}
}
```

## 单例设计模式的体现：

### 饿汉式

```
class Single
{
    private Single(){}
    private static Single s = new Single();
    public static Single getInstance(){
        return s;
    }
}
```

#### 特点：

1：single类一加载进来后，就创建好了对象（方法区中有s, 就要堆中建立对象，分配内存，将地址赋给s）

2：开发一般用这个，安全且简单，确保了对象一定存在

### 懒汉式（面试常用）

- 方法被调用时才初始化，也叫做对象的延迟加载

```
class Single
{
    private static Single s = null;
    private Single(){}
    public static synchronized Single getInstance(){
        if(s == null)
        	s = new Single();
        return s;
    }
}

main(){
    Single s1 = Single.getInstance();
}
```

#### 特点：

1：single类加载进来后，方法区中有s, 但s是Null,只有在调用方法后，才建立对象。

2：有可能cpu一处理到 ：

- A程序中 s == null, 就转去别的事情；
- 然后回来了，B程序来了，B程序中 s == null, 就转去别的事情；

- cpu再回来A新建对象
- cpu再转去B，B还要new 对象，此时对象不唯一。

#### **解决**：

#### 1. 同步锁：synchronized， 让A一进来，其他的就进不来了。低效

#### 2.**更好的解决方案：双重判断**，多线程用

```
class Single
{
    private static Single s = null;
    private Single(){}
    public static Single getInstance(){
        if(s == null){
        	synchronized（Single.class){
        		if(s == null)
        			s = new Single();
        	}
        }
        return s;
    }
}
```

- A进来，满足null，拿锁
- B进来，满足null,  进不去

### 使用容器模式实现单例

将众多单例模式类型注入到一个统一的管理类中，在使用时根据key 对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度

```java
public class SingletonManager {
    private static Map<String, Object> obMap = new HashMap<String, Object>();
    private SingletonManager() {}
    public static void registerService (String key, Object instance) {
        if (obMap.containsKey(key)) {
            obMap.put(key, instance);
        }
    }

    public static Object getService (String key) {
        return obMap.get(key);
    }
}
```

