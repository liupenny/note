# 泛型

## 存在的安全问题

### 1）原来

```
public static void main(String[] args) {
	ArrayList al = new ArrayList();
	al.add("hahah");
	al.add(4);
		
	Iterator<String> it = al.iterator();
	while(it.hasNext()){
		String str = (String)it.next();
		System.out.println(str);
	}
}
```

- 上面写法的（String）强制类型转换，当加入4的时候会**在运行时**报错，造成安全问题

### 2）修改后：加上明确类型

```
public static void main(String[] args) {
	ArrayList<String> al = new ArrayList<String>();
		
	al.add("abc");//public boolean add(Object obj)
	al.add("hahah");
		
		Iterator<String> it = al.iterator();
		while(it.hasNext()){
			
			String str = it.next();
			System.out.println(str);
		}
	}
```

## 明确类型的优点：

- add(4) 在编译时就会报错：将问题转移到了编译时期，方便程序员解决问题，让运行时问题减少，更安全
- `Iterator<String>`，因为是取元素到iterator中，所以也要设定iterator的类型。避免了强制转换的问题。

## 泛型的优点

1. 类型安全，提供编译期间的类型检测
2. 前后兼容
3. 泛化代码,代码可以更多的重复利用
4. 性能较高，用GJ(泛型JAVA)编写的代码可以为java编译器和虚拟机带来更多的类型信息，这些信息对java程序做进一步优化提供条件

## 限定通配符和非限定通配符

有两种限定通配符

- <? extends T>，通过确保类型必须是T的子类来设定类型的上界
- <? super T>，通过确保类型必须是T的父类来设定类型的下界。
- 泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。

<?>表示非限定通配符，因为<?>可以用任意类型来替代

T 可以是类也可以是接口，在泛型中没有implement关键字

**指定多个绑定类型**：例如<? extends T & U>

**PECS原则（REWS，Read Extends Write Super）**

- 如果要从集合中读取类型T的数据，并且不能写入，可以使用<? extends>通配符；(Producer Extends)

  例如，对于Pair<? extends Employee>

  ```java
  ? extends Employee getFirst(); // 可以将返回值赋给一个Employee引用，相当于有一个上限，合法
  void setFirst(? extends Employee); // 编译器只知道需要某个Employee子类，但不知道具体什么类型，不能赋值给Employee引用进行操作，不合法
  ```

- 如果要从集合中写入类型T的数据，并且不需要读取，可以使用<? super>通配符；(Consumer Super)

  例如，对于Pair<? super Manager>

  ```java
  ? super Manager getFirst(); // 返回对象不能得到保证，只能返回Object，不合法
  void setFirst(? super Manager); // 虽然不知道具体类型，但可以强制转换为Manager操作，合法
  ```

- 如果既要存又要取，那么就不要使用任何通配符。

## 类型擦除

- 泛型是 Java 1.5 版本才引进的概念，在这之前是没有泛型的概念的，但显然，泛型代码能够很好地和之前版本的代码很好地兼容。

这是因为，**泛型信息只存在于代码编译阶段**，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。

通俗地讲，泛型类和普通类在 java 虚拟机内是没有什么特别的地方。回顾文章开始时的那段代码

```java
List<String> l1 = new ArrayList<String>();
List<Integer> l2 = new ArrayList<Integer>();

System.out.println(l1.getClass() == l2.getClass());
```

打印的结果为 true 是因为 List<String> 和 List<Integer> 在 jvm 中的 Class 都是 List.class。泛型信息被擦除了。

- 那么类型 String 和 Integer 怎么办

在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 `<T>` 则会被转译成普通的 Object 类型，如果指定了上限如 `<T extends String>` 则类型参数就被替换成类型上限。 

答案是泛型转译

# 泛型的使用

## 1. 通过<>来定义要操作的引用数据类型，只要见到<>就到定义泛型

## 2. 比较器的应用：compartor也不用强转了

原来：

```java
public class ComparatorByName implements Comparator {
    @Override
    public int compare(Object o1, Object o2) {
        String s1 = (String)o1;
        String s2 = (String)o2;

        int temp = s1.length()-s2.length();
        // 字符串的compareTo方法
        return temp==0? s1.compareTo(s2): temp;
    }
}
```

现在：

```java
public class ComparatorByName implements Comparator<Person> {
    @Override
    public int compare(Person o1, Person o2) {
        int temp = o1.getName().compareTo(o2.getName());
        return temp==0? o1.getAge()-o2.getAge(): temp;
    }
}
```

## 3. 自定义泛型类

### 早期方法：只能定义object类，还需要强转,会出错

```java
public class Tool {
    private Object object;
    public Object getObject() {
        return object;
    }
    public void setObject(Object object) {
        this.object = object;
    }
}

main()
{
    Tool t =new Tool();
    t.setObject(new Student());
    Worker w = (Worker)t.getObject();
}
```

### 泛型类

什么时候定义泛型类？

- 当类中要操作的引用数据类型不确定的时候用，将错误转移到了编译时期，编译的时候`Worker w = t.getObject();`报错
- main函数中指定好集合的类型，如果插入不同类型就会运行时报错

```
class Utils<Q> {
	private Q q;
	public Q getObject(Q q) {
		return q;
	}
	public void setObject(Q q) {
		this.q = q;
	}
}

main()
{
    Utils<Worker> t =new Utils<Worker>();
    t.setObject(new Student());
    Worker w = t.getObject();
}
```

## 4.泛型方法。泛型定义在方法上，放在返回值类型前面，修饰符后面

为了不同方法操作不同类型，而且类型还不确定，可以将泛型定义在方法上

这样就可以传入两个不同的类型数据

```
class Utils {
    public <W> void show(W str){
        System.out.println("show : " + str;
    }
    public void print(QQ str){
        System.out.println("print : " + str);
    }
}

main()
{
    Utils t =new Utils();
    t.show("sss");
    t.show(4);
}
```

## 5. 泛型类+泛型方法

```
public class Utils<QQ>{
	public <W> void show(W str){
		System.out.println("show : "+str);
	}
	public void print(QQ str){
		System.out.println("print : "+str);
	}
}
main()
{
    Utils<Integer> t =new Utils<Integer>();
    t.show("sss");
    t.show(4);
    t.print(6);
}
```

## 6.静态泛型函数  

```
// 下面会报错，因为Y类型是要实例化后才能知道
public static void method(Y obj){
	System.out.println("method:"+obj);
}

当方法静态时，不能访问类上定义的泛型。如果静态方法需要使用泛型，只能将泛型定义在方法上。 
public static <Y> void method(Y obj){
	System.out.println("method:"+obj);
}
```

## 7.泛型定义在接口上

### 1）将类型定义在实现的方法上

```
public class GenericDefineDemo5 {
	public static void main(String[] args) {
		InterImpl in = new InterImpl();
		in.show("abc");
	}
}

//泛型接口，将泛型定义在接口上。 
interface Inter<T>{
	public void show(T t);
}

// 将类型定义在实现的方法上
class InterImpl2 implements Inter<String>{
	public void show(String q){
		System.out.println("show :"+q);
	}
}
```

### 2）实现的时候也用泛型

```
public class GenericDefineDemo5 {
	public static void main(String[] args) {
		InterImpl in = new InterImpl();
		in.show("abc");
		
		InterImpl2<Integer> in2 = new InterImpl2<Integer>();
		in2.show(5);
	}
}

//泛型接口，将泛型定义在接口上。 
interface Inter<T>{
	public void show(T t);
}
//实现的方法也是泛型
class InterImpl2<Q> implements Inter<Q>{
	public void show(Q q){
		System.out.println("show :"+q);
	}
}
```

## 8.迭代并打印集合中元素

当类型不知道的时候用通配符'?'表示,下面两种写法都行

```
public class GenericAdvanceDemo {
	public static void main(String[] args) {
		ArrayList<String> al = new ArrayList<String>();
		al.add("abc");
		al.add("hehe");
		
		ArrayList<Integer> al2 = new ArrayList<Integer>();
		al2.add(5);
		al2.add(67);
		
		printCollection(al);
		printCollection(al2);
	}
}
```

### 1.public static void printCollection(Collection<?> al) 	

```
public static void printCollection(Collection<?> al) {	
		Iterator<?> it = al.iterator();
		while(it.hasNext()){
			System.out.println(it.next();
		}	
	}
```

### 2.public static <T> void printCollection(Collection<T> al) 

T代表一个具体类型，这样内部就可以操作他了（`T str = it.next();`）

```
public static void printCollection(Collection<?> al) {	
		Iterator<?> it = al.iterator();
		
		while(it.hasNext()){
			// 具体操作
			T str = it.next();
			System.out.println(str);
			// toString是所有类都有的方法，可以用
			System.out.println(it.next().toString());
		}	
	}
```

### 8.1. 泛型限定：有继承类的时候，泛型方法使用

student继承Person.

`ArrayList<Person> a = new ArrayList<Student>(); 会报错,因为会有类型安全问题`

**集合类型的左右两边必须一致**

```
ArrayList<Student> al2 = new ArrayList<Person>(); 会报错
```

student类继承person类，泛型限定表示继承关系`? super Student`

```
public static void printCollection(Collection<? super Student> al){
		Iterator<? super Student> it = al.iterator();
		while(it.hasNext()){
			System.out.println(it.next());
		}
	}
```

### 8.2 说明

?  通配符，也可以理解为占位符

 可以对类型进行限定：
 ? extends E:接收E类型或者E的子类型对象。上限！因为E确定了，即父类是确定的
 ? super E ：接收E类型或者E的父类型。下限！

### 8.3 举例

TreeSet<E> 可以接收一个比较器，比较器的参数写的是Comparator<? super E>。即定义一个treeset<student>，其可以接收的比较器参数可以是student或者student的父类

当下，worker，student类都继承Person。可以对TreeSet<Student> al2，TreeSet<Worker> al3，传入一个参数类型为Person的比较器即可。

```
TreeSet<Student> al2 = new TreeSet<Student>(new CompByName());
al2.add(new Student("stu1",11));
al2.add(new Student("stu7",20));
al2.add(new Student("stu2",22));
			
TreeSet<Worker> al3 = new TreeSet<Worker>(new CompByName());		
al3.add(new Worker("stu1",11));
al3.add(new Worker("stu2",22));

class CompByName implements Comparator<Person>{
	public int compare(Person o1, Person o2) {		
		int temp = o1.getName().compareTo(o2.getName());
		return temp==0? o1.getAge()-o2.getAge():temp;
	}
}
```

