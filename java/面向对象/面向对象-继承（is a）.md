# 面向对象-继承（is a） 

## 本身介绍

### 优点

1：提高代码复用性

2：让类与类之间产生了所属关系is a 

3：支持多层继承（C是父类，B可以继承C，A可以继承B。A可以使用C的内容）

**Q：如何使用一个继承体系中的功能？**

想要使用体系，**先查阅体系父类的描述**，因为父类中定义的是该体系中共性功能。通过共性功能，就知道该体系的基本功能。在具体调用的时候，要**创建其子类的对象**

1：有可能父类不能创建对象

2：创建子类对象可以使用多个功能

### 注意

1：不要为了获取其他类的功能，简化代码而继承

2：必须是类与类之间的所属关系才可以继承，is  a

3：只支持单继承，不支持多继承。因为多继承容易带来安全隐患（当多个父类中定义了相同名字的函数，但功能不同的函数时，子类不知道该运行哪个--- 可以用**“多实现”**机制实现）

### 其他关系：

- 聚集关系：has a 

  谁里面有谁

- 聚合：

  e.g. : 一个球队由多个球员组成，球队和球员的关系

- 组合：

  紧密联系更高, e.g. : 心脏是身体的一个组成部分

## 子父类中的变量特点

类中成员：

1：变量

2：函数

3：构造函数

### 变量

如果子类中出现非私有的同名成员变量，访问本类变量用this,访问父类变量用super

```
class Fu
{
	int num  = 5;
}

class Zi extends Fu{
    int num  = 4;
    public void out() {
        System.out.println(super.num);
    }
}
```

加载zi.class之前会先加载fu.class，方法区先有Fu。无论FU的Num是不是私有，Zi 和 Fu的变量都在堆内存中有地址，子类对象的属性区包含：子类变量，父类变量，只不过使用权限不一样。

![](https://note.youdao.com/yws/public/resource/f2168540caf26c25109a3234bac42594/xmlnote/5AC5B707387A4E559899BD7A30FF9BB4/49747)

### 函数

覆盖（重写）：当子类出现和父类同名的函数时，调用该方法会调用子类的同名方法。

**注意**

1：静态只能覆盖静态

2：子类覆盖静态，必须保证子类权限（private , public , 默认权限-什么都不写（public>默认权限>private））大于等于父类

3：重写--子父类方法要一模一样，返回值都要一样

​      重载--只在乎参数列表

**应用1：子父类功能相同，内容不同，可用覆盖**

```
class Fu
{
	public void speak() {
        System.out.println("vb");
    }
}

class Zi extends Fu{
    public void speak() {
        System.out.println("java");
    }
}
```

**应用2：产品更新，覆写**

```
class Fu
{
	public void speak() {
        System.out.println("number");
    }
}

class Zi extends Fu{
    public void speak() {
    	super.speak();
        System.out.println("java");
    }
}
```

### 构造函数

- 子类的构造函数和父类的构造函数不能覆写

- 在对子类对象进行初始化时，父类的构造函数也会运行 ，因为子类构造函数第一行有默认的super(); super()函数会访问父类中空参数的构造函数。

- 一个子类的所有构造函数第一行默认的都是super()；

- super()语句一定要放在构造函数的第一行

- 第一行只能是super(), 或者是this(). 且只能写一个。写this()的就是另一个构造函数调用了super()

  ```
  class Zi extends Fu{
  	Zi(){
          //默认有super();
          print(2);
  	}
  	
  	Zi(){
          this();
          print(20);
  	}
      public void speak() {
      	super.speak();
          System.out.println("java");
      }
  }
  ```

- 当父类没有空参数的super()；时，子类也要显示写出super(参数)；

**问题：为什么子类一定要访问父类的构造函数？**

- 因为父类中的数据子类可以直接获取，所以子类对象在建立时，需要先查看父类是如何对这些数据进行初始化的。所以子类在对象初始化时，要先访问父类的构造函数，需要参考父类的结果； 如果要访问父类中指定的构造函数，可以通过手动定义super语句的方式来指定。

## 关键字final（修饰符）

1：可以修饰类、变量、函数

2：被final修饰的类不可以被继承。防止继承后覆写修改原有内容，不让子类继承，这样原方法中所有函数都不能被覆写

3：被final修饰的方法不可以被覆写，这样父类可以有子类，一些方法不能被覆写

4：被final修饰的变量是一个常量，只能赋值一次，既可以修饰成员变量，也可以修饰局部变量

5：内部类定义在类中的局部位置上时，只能访问该局部被final修饰的局部变量

6：用全大写的标识符起名字，即使只用一次也用final

# 接口

## 抽象类

- 当多个类中出现了相同功能，但功能中主体不同，这时可以进行向上抽取：抽取功能定义，而不抽取功能主体。父类里只定义抽象的功能描述，就是一个需求

### 抽象类的特点

1：抽象方法一定在抽象类中

2：抽象方法和抽象类必须被abstract关键字修饰

3：抽象类不可以用New 创建对象，因为调用抽象方法没意义

4：抽象类中的方法要被调用，**必须**由子类覆写所有的抽象方法后，建立子类对象调用。如果子类只覆盖了部分抽象方法，该子类还是一个抽象类

```
abstract class Student
{
	// 没有方法体{}
	abstract void study();
	// 如果还有下面这句话，AdvStudent还是一个抽象类
	abstract void study1();
}

class BaseStudent extends Student
{
	// 对抽象类进行覆写
	void Study()
	{
		print("");
	}
}

// 还是一个抽象类
abstract class AdvStudent extends Student
{
	// 对抽象类进行覆写
	void Study()
	{
		print("");
	}
	// 部分函数抽象
	abstract void study1();
}
```

5：抽象类和一般类没有太大的不同，该怎样描述事物就怎样描述，只不过该事物中出现了一些抽象的不确定的部分，也是该事物的功能，但无法定义主体，用抽象方法去表示。子类中去具体描述这个事情。

6：抽象：只能用于修饰类，和方法。所以抽象类中可以不定义方法，**唯一作用**：防止new 该类对象。

## 模板方法设计模式

**Q：什么是模板方法**？

在定义功能时，功能的一部分是确定的，一部分是不确定的，而确定的部分在使用不确定的部分，将不确定的部分暴露出去，由该类的子类去完成。

确定的部分用final（避免被覆盖），暴露出去的也不一定是abstract（有时候有默认实现）。

**e.g.**

 如下获取程序运行时间，获取运行时间的代码是确定的，程序是不确定的。

![](https://note.youdao.com/yws/public/resource/f2168540caf26c25109a3234bac42594/xmlnote/1B729BA7E6EF41C28675ED57B18BC3CF/49752)

## 初步理解：

一个特殊的抽象类。当抽象类中的方法全都是抽象方法，该类可以用接口的形式来表示。

## 格式特点：

1：接口中常见定义：常量，抽象方法

2：接口中的成员都有固定修饰符

常量：public static final

方法：public abstract

## 与类的关系：实现

1：接口中的成员都是public。只要写了Interface, 内部的成员修饰符会系统给补上。

2：接口不能创建对象，因为有抽象方法，需要被子类去**实现**接口。子类对接口中的抽象方法全都覆盖后，子类才可以实例化，否则子类是一个抽象类。

继承：父类中有非抽象的东西

实现：子类很辛苦，所有东西都要自己实现

3：Interface 也是一个类，其变量也可以访问

![](https://note.youdao.com/yws/public/resource/f2168540caf26c25109a3234bac42594/xmlnote/F11C50B3086145D68E4852E235086D66/49750)

### 多实现：接口可以被类多实现（一个类可以同时实现多个接口）

- 两个接口中定义了名字相同的函数，子类中可只覆写一次该函数。
- 先继承，再实现，可以扩展功能

## 接口、类的关系：

- 类与类：单继承

- 类与接口：实现，多实现

- 接口与接口：继承，多继承

  下图展示了：test继承Demo类，多实现inter,interA接口。并且只用实现一个show即可。

  ![](https://note.youdao.com/yws/public/resource/f2168540caf26c25109a3234bac42594/xmlnote/6151A294E31A4854817C537462A04F5F/49754)

  若每个接口内有不同的函数，则每个函数都要实现。且不能有同名却返回值类型不同的函数

  ![](https://note.youdao.com/yws/public/resource/f2168540caf26c25109a3234bac42594/xmlnote/1085ECC3733B432D896141BE79155EC0/49756)

## 特点

1：接口是对外暴露的规则

2：接口是**程序的扩展**。

e.g. 老师和同学都是人，属于Person类。但是抽烟是扩展，二者都可以。但抽烟不能在Person类中。

3：接口可以用来多实现

4：类和接口之间是实现关系，而且类可以继承一个类的同时实现多个接口

5：接口与接口之间可以有继承关系

