# 多线程实战指南

# 一：多线程编程的目标与挑战

并行、并发

竟态：计算结果的正确性依赖于相对顺序

原因：多个线程在没有采取控制的情况下并发地更新、读取一个共享变量

竟态模式：

1. 读-改-写：

   e.g.   id++ .先读到寄存器①、寄存器加一②、写回内存③

2. check-then-act（读取某个共享变量值，根据值决定下一步做什么）

   e.g.   if ( a = 1)①check {②操作} else {}

   在结束①到开始②之间，a可能被更新导致if不成立。

竟态产生条件：

设O1,O2是并发访问共享变量V的两个非都是读的操作，若一个线程在执行O1期间，另一个线程在执行O2，就会导致竟态。

## 线程安全问题：原子性、可见性、有序性

### 1.**原子性：**

操作不可分割。使一个操作具备原子性也就消除了该操作导致竟态的可能性。

Java中有两种方式来实现原子性：

1. lock锁，有排他性，软件层面
2. cas指令，硬件层面

java中，除long/double外，其他基础类型or引用类型变量的**写操作**都是原子的。此时可用volatile关键字修饰。对于任何变量的读操作都是原子的。

### 2.**可见性：** 

一个线程对共享变量的更新的结果，对于读取变量的线程而言是否可见。

**可见性问题原因：**

处理器通过：寄存器、高速缓存cache、写缓冲器、无效化队列等（统称为处理器缓存）执行内存的读写操作。处理器只能读到内存的数据，当处理器上运行的线程将共享变量更新到处理器缓存时，另一个线程的处理器不一定能读到，即内存可见性问题。

e.g. 

1. 每个处理器都有其寄存器，一个处理器无法读取另一个处理器中寄存器的内容。所以如果两个线程分别运行在不同的处理器上，且共享变量被分到寄存器存储，就会有可见性问题。
2. 单处理器上：一个线程对寄存器变量的修改被当做线程上下文保存起来，其他线程看不到修改，也是可见性问题。

**可见性解决方案：**

缓存同步：处理器可以通过缓存一致性协议来读取其他处理器的高速缓存中的数据，并将读到的数据更新到该处理器的高速缓存中。

冲刷处理器缓存：使一个处理器对共享变量所做的更新最终被写入该处理器的高速缓存or主内存中。而不是停留在其写缓冲器中。

刷新处理器缓存：一个处理器在读取共享变量时，若其他处理器在此之前已经更新了改变量，该处理器必须从其他处理器的高速缓存或主内存中对相应的变量进行缓存同步。

可见性的保障：更新共享变量的处理器执行冲刷，读取共享变量的处理器执行刷新操作。

**Java实现可见性：使用volatile**

1. 防止jit编译器优化
2. 使得读写的处理器进行处理器缓存的冲刷or刷新。

约定：

对于共享变量而言，

相对新值：一个线程更新了改变量的值之后，其他线程能读到的这个值

最新值：读取这个变量的线程在读取并使用改变量的时候，其他线程无法更新改变量的值，该线程读到的相对新值就是最新值。

可见性只能保障线程读到相对新值，不能保障最新值。

### 3.有序性：

多核处理器环境下的重排序：

1. 编译器可能改变操作的先后顺序
2. 处理器不按照代码顺序执行
3. 一个处理器上执行的操作，从其他处理器的角度来看顺序与代码不一致。

重排序：对内存访问有关操作的优化

![1562143998740](.\assets\1562143998740.png)

**编译器重排序：**

Java平台包含两种编译器：静态编译器（ javac ）和动态编译器（JIT编译器）。前
者的作用是将Java 源代码（ .java文本文件）编译为字节码（ .class 二进制文件），它
是在代码编译阶段介入的。后者的作用是将字节码动态编译为Java虚拟机宿主机的本
地代码（机器码），它是在Java程序运行过程中介入的。

javac不会进行指令重排，jit会。

**处理器重排序：**

也叫作乱序执行：指令按程序顺序被处理器读取，然后哪条指令就绪就先执行哪条，然后进入重排序缓冲器（ROB），而不是直接写入寄存器或主内存。ROB会将结果按照读取顺序写入寄存器或主内存。

乱序执行还采用了猜测执行技术：先执行再判断，多线程时导致错误结果。

## 线程的活性故障

线程活性故障：由于一些问题导致线程一直处于非runnable状态，或处于runnable状态但其要执行的任务却一直无法进展的状态（活锁）。

比如：死锁，锁死，活锁，饥饿

## 本章总结

![1562156674028](.\assets\1562156674028.png)

# 线程同步机制

注意是：协调线程间共享数据访问的相关关键字和API

## 锁的概念

排它锁、读写锁

**按java虚拟机对锁的实现方式划分：**java平台中的锁包括：内部锁（intrinsic lock）、显式锁。

内部锁：synchronized关键字

显式锁：lock接口的实现类：ReentrantLock

**锁的作用：**保障原子性、可见性、有序性

通过互斥保障原子性、

锁的获取与释放保障了刷新处理器缓存与冲刷处理器缓存保障可见性

**锁的使用条件：**

1. 线程在访问同一组共享数据的时候必须使用同一个锁
2. 线程中的任一线程，即使只是读取这组数据而不更新也要在读取时获得锁

**与锁相关的概念：**

1.可重入性

2.锁的调度：公平or非公平

内部锁是非公平锁，显示锁两个都支持

3.锁的粒度

4.锁的开销

5.锁的不正确使用导致的活性故障

### 适用场景

1. check-then-act：读取共享数据，并在此基础上决定下一步做什么
2. read-modify-write：读取并操作
3. 多个线程对多个共享数据操作，数据间有关联关系

## 内部锁synchronized

任何一个对象都有一个与之关联的锁，称为监视器或内部锁。常用private final修饰的变量来当锁句柄。

即使临界区代码抛出异常，内部锁也不会导致死锁。

锁有一个entry set，未申请成功的线程在集合中排队等待唤醒。

java1.7对其进行优化，比如：偏向锁

## 显示锁lock

在finally执行，避免死锁

### 二者比较

1. 内部锁基于代码块不灵活，只能在一个方法内。显示锁基于对象，可以跨方法。

2. lock有更多方法可以对锁进行监控

### 读写锁

之前的锁无法使多个线程对共享变量进行读操作，读写锁是一种改进型的排它锁。

多个线程同时读，一次只能一个线程更新；

任何线程读，其他线程都不能写；

一个线程写，其他线程都不能读。

juc中的ReadWriteLock接口是对读写锁的抽象，其实现类是：juc的ReentrantReadWriteLock.

使用场景：

1.只读操作比写操作频繁得多

2.读线程持有锁的时间较长





